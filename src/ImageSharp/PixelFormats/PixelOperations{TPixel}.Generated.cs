// Copyright (c) Six Labors.
// Licensed under the Apache License, Version 2.0.
// <auto-generated />

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace SixLabors.ImageSharp.PixelFormats
{
    public partial class PixelOperations<TPixel>
    {
        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Argb32"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Argb32"/> data.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        public virtual void FromArgb32(Configuration configuration, ReadOnlySpan<Argb32> source, Span<TPixel> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destinationPixels, nameof(destinationPixels));
            
            ref Argb32 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Argb32 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromArgb32(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromArgb32(Configuration, ReadOnlySpan{Argb32}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Argb32"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromArgb32Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destinationPixels, int count)
        {
            this.FromArgb32(configuration, MemoryMarshal.Cast<byte, Argb32>(sourceBytes).Slice(0, count), destinationPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Argb32"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destinationPixels">The destination span of <see cref="Argb32"/> data.</param>
        public virtual void ToArgb32(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<Argb32> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destinationPixels, nameof(destinationPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Argb32 destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Argb32 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToArgb32(Configuration, ReadOnlySpan{TPixel}, Span{Argb32})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Argb32"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToArgb32Bytes(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToArgb32(configuration, sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Argb32>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Bgr24"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Bgr24"/> data.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        public virtual void FromBgr24(Configuration configuration, ReadOnlySpan<Bgr24> source, Span<TPixel> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destinationPixels, nameof(destinationPixels));
            
            ref Bgr24 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Bgr24 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromBgr24(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromBgr24(Configuration, ReadOnlySpan{Bgr24}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Bgr24"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromBgr24Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destinationPixels, int count)
        {
            this.FromBgr24(configuration, MemoryMarshal.Cast<byte, Bgr24>(sourceBytes).Slice(0, count), destinationPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Bgr24"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destinationPixels">The destination span of <see cref="Bgr24"/> data.</param>
        public virtual void ToBgr24(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<Bgr24> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destinationPixels, nameof(destinationPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Bgr24 destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Bgr24 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToBgr24(Configuration, ReadOnlySpan{TPixel}, Span{Bgr24})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Bgr24"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToBgr24Bytes(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToBgr24(configuration, sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Bgr24>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Bgra32"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Bgra32"/> data.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        public virtual void FromBgra32(Configuration configuration, ReadOnlySpan<Bgra32> source, Span<TPixel> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destinationPixels, nameof(destinationPixels));
            
            ref Bgra32 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Bgra32 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromBgra32(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromBgra32(Configuration, ReadOnlySpan{Bgra32}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Bgra32"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromBgra32Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destinationPixels, int count)
        {
            this.FromBgra32(configuration, MemoryMarshal.Cast<byte, Bgra32>(sourceBytes).Slice(0, count), destinationPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Bgra32"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destinationPixels">The destination span of <see cref="Bgra32"/> data.</param>
        public virtual void ToBgra32(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<Bgra32> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destinationPixels, nameof(destinationPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Bgra32 destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Bgra32 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToBgra32(Configuration, ReadOnlySpan{TPixel}, Span{Bgra32})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Bgra32"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToBgra32Bytes(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToBgra32(configuration, sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Bgra32>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="L8"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="L8"/> data.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        public virtual void FromL8(Configuration configuration, ReadOnlySpan<L8> source, Span<TPixel> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destinationPixels, nameof(destinationPixels));
            
            ref L8 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref L8 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromL8(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromL8(Configuration, ReadOnlySpan{L8}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="L8"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromL8Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destinationPixels, int count)
        {
            this.FromL8(configuration, MemoryMarshal.Cast<byte, L8>(sourceBytes).Slice(0, count), destinationPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="L8"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destinationPixels">The destination span of <see cref="L8"/> data.</param>
        public virtual void ToL8(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<L8> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destinationPixels, nameof(destinationPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref L8 destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref L8 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToL8(Configuration, ReadOnlySpan{TPixel}, Span{L8})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="L8"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToL8Bytes(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToL8(configuration, sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, L8>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="L16"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="L16"/> data.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        public virtual void FromL16(Configuration configuration, ReadOnlySpan<L16> source, Span<TPixel> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destinationPixels, nameof(destinationPixels));
            
            ref L16 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref L16 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromL16(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromL16(Configuration, ReadOnlySpan{L16}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="L16"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromL16Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destinationPixels, int count)
        {
            this.FromL16(configuration, MemoryMarshal.Cast<byte, L16>(sourceBytes).Slice(0, count), destinationPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="L16"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destinationPixels">The destination span of <see cref="L16"/> data.</param>
        public virtual void ToL16(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<L16> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destinationPixels, nameof(destinationPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref L16 destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref L16 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToL16(Configuration, ReadOnlySpan{TPixel}, Span{L16})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="L16"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToL16Bytes(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToL16(configuration, sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, L16>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="La16"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="La16"/> data.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        public virtual void FromLa16(Configuration configuration, ReadOnlySpan<La16> source, Span<TPixel> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destinationPixels, nameof(destinationPixels));
            
            ref La16 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref La16 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromLa16(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromLa16(Configuration, ReadOnlySpan{La16}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="La16"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromLa16Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destinationPixels, int count)
        {
            this.FromLa16(configuration, MemoryMarshal.Cast<byte, La16>(sourceBytes).Slice(0, count), destinationPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="La16"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destinationPixels">The destination span of <see cref="La16"/> data.</param>
        public virtual void ToLa16(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<La16> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destinationPixels, nameof(destinationPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref La16 destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref La16 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToLa16(Configuration, ReadOnlySpan{TPixel}, Span{La16})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="La16"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToLa16Bytes(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToLa16(configuration, sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, La16>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="La32"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="La32"/> data.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        public virtual void FromLa32(Configuration configuration, ReadOnlySpan<La32> source, Span<TPixel> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destinationPixels, nameof(destinationPixels));
            
            ref La32 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref La32 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromLa32(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromLa32(Configuration, ReadOnlySpan{La32}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="La32"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromLa32Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destinationPixels, int count)
        {
            this.FromLa32(configuration, MemoryMarshal.Cast<byte, La32>(sourceBytes).Slice(0, count), destinationPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="La32"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destinationPixels">The destination span of <see cref="La32"/> data.</param>
        public virtual void ToLa32(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<La32> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destinationPixels, nameof(destinationPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref La32 destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref La32 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToLa32(Configuration, ReadOnlySpan{TPixel}, Span{La32})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="La32"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToLa32Bytes(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToLa32(configuration, sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, La32>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Rgb24"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgb24"/> data.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        public virtual void FromRgb24(Configuration configuration, ReadOnlySpan<Rgb24> source, Span<TPixel> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destinationPixels, nameof(destinationPixels));
            
            ref Rgb24 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Rgb24 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromRgb24(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromRgb24(Configuration, ReadOnlySpan{Rgb24}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgb24"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromRgb24Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destinationPixels, int count)
        {
            this.FromRgb24(configuration, MemoryMarshal.Cast<byte, Rgb24>(sourceBytes).Slice(0, count), destinationPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Rgb24"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destinationPixels">The destination span of <see cref="Rgb24"/> data.</param>
        public virtual void ToRgb24(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<Rgb24> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destinationPixels, nameof(destinationPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Rgb24 destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Rgb24 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToRgb24(Configuration, ReadOnlySpan{TPixel}, Span{Rgb24})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Rgb24"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToRgb24Bytes(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToRgb24(configuration, sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Rgb24>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Rgba32"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgba32"/> data.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        public virtual void FromRgba32(Configuration configuration, ReadOnlySpan<Rgba32> source, Span<TPixel> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destinationPixels, nameof(destinationPixels));
            
            ref Rgba32 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Rgba32 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromRgba32(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromRgba32(Configuration, ReadOnlySpan{Rgba32}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgba32"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromRgba32Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destinationPixels, int count)
        {
            this.FromRgba32(configuration, MemoryMarshal.Cast<byte, Rgba32>(sourceBytes).Slice(0, count), destinationPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Rgba32"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destinationPixels">The destination span of <see cref="Rgba32"/> data.</param>
        public virtual void ToRgba32(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<Rgba32> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destinationPixels, nameof(destinationPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Rgba32 destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Rgba32 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToRgba32(Configuration, ReadOnlySpan{TPixel}, Span{Rgba32})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Rgba32"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToRgba32Bytes(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToRgba32(configuration, sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Rgba32>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Rgb48"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgb48"/> data.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        public virtual void FromRgb48(Configuration configuration, ReadOnlySpan<Rgb48> source, Span<TPixel> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destinationPixels, nameof(destinationPixels));
            
            ref Rgb48 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Rgb48 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromRgb48(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromRgb48(Configuration, ReadOnlySpan{Rgb48}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgb48"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromRgb48Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destinationPixels, int count)
        {
            this.FromRgb48(configuration, MemoryMarshal.Cast<byte, Rgb48>(sourceBytes).Slice(0, count), destinationPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Rgb48"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destinationPixels">The destination span of <see cref="Rgb48"/> data.</param>
        public virtual void ToRgb48(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<Rgb48> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destinationPixels, nameof(destinationPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Rgb48 destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Rgb48 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToRgb48(Configuration, ReadOnlySpan{TPixel}, Span{Rgb48})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Rgb48"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToRgb48Bytes(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToRgb48(configuration, sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Rgb48>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Rgba64"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgba64"/> data.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        public virtual void FromRgba64(Configuration configuration, ReadOnlySpan<Rgba64> source, Span<TPixel> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destinationPixels, nameof(destinationPixels));
            
            ref Rgba64 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Rgba64 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromRgba64(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromRgba64(Configuration, ReadOnlySpan{Rgba64}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgba64"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromRgba64Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destinationPixels, int count)
        {
            this.FromRgba64(configuration, MemoryMarshal.Cast<byte, Rgba64>(sourceBytes).Slice(0, count), destinationPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Rgba64"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destinationPixels">The destination span of <see cref="Rgba64"/> data.</param>
        public virtual void ToRgba64(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<Rgba64> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destinationPixels, nameof(destinationPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Rgba64 destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Rgba64 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToRgba64(Configuration, ReadOnlySpan{TPixel}, Span{Rgba64})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Rgba64"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToRgba64Bytes(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToRgba64(configuration, sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Rgba64>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Bgra5551"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Bgra5551"/> data.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        public virtual void FromBgra5551(Configuration configuration, ReadOnlySpan<Bgra5551> source, Span<TPixel> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destinationPixels, nameof(destinationPixels));
            
            ref Bgra5551 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Bgra5551 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromBgra5551(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromBgra5551(Configuration, ReadOnlySpan{Bgra5551}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Bgra5551"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destinationPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromBgra5551Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destinationPixels, int count)
        {
            this.FromBgra5551(configuration, MemoryMarshal.Cast<byte, Bgra5551>(sourceBytes).Slice(0, count), destinationPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Bgra5551"/>-s.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destinationPixels">The destination span of <see cref="Bgra5551"/> data.</param>
        public virtual void ToBgra5551(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<Bgra5551> destinationPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destinationPixels, nameof(destinationPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Bgra5551 destBaseRef = ref MemoryMarshal.GetReference(destinationPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Bgra5551 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToBgra5551(Configuration, ReadOnlySpan{TPixel}, Span{Bgra5551})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Bgra5551"/> layout.
        /// </summary>
        /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToBgra5551Bytes(Configuration configuration, ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToBgra5551(configuration, sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Bgra5551>(destBytes));
        }
    }
}
