// Copyright (c) Six Labors.
// Licensed under the Six Labors Split License.
// <auto-generated />

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace SixLabors.ImageSharp.PixelFormats;

public partial class PixelOperations<TPixel>
{
    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="Argb32"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Argb32"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromArgb32(Configuration configuration, ReadOnlySpan<Argb32> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref Argb32 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromArgb32(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromArgb32(Configuration, ReadOnlySpan{Argb32}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Argb32"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromArgb32Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromArgb32(configuration, MemoryMarshal.Cast<byte, Argb32>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="Argb32"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="Argb32"/> data.</param>
    public virtual void ToArgb32(Configuration configuration, ReadOnlySpan<TPixel> source, Span<Argb32> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref Argb32 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = Argb32.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToArgb32(Configuration, ReadOnlySpan{TPixel}, Span{Argb32})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="Argb32"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToArgb32Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToArgb32(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, Argb32>(destination));
    }

    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="Abgr32"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Abgr32"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromAbgr32(Configuration configuration, ReadOnlySpan<Abgr32> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref Abgr32 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromAbgr32(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromAbgr32(Configuration, ReadOnlySpan{Abgr32}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Abgr32"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromAbgr32Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromAbgr32(configuration, MemoryMarshal.Cast<byte, Abgr32>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="Abgr32"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="Abgr32"/> data.</param>
    public virtual void ToAbgr32(Configuration configuration, ReadOnlySpan<TPixel> source, Span<Abgr32> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref Abgr32 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = Abgr32.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToAbgr32(Configuration, ReadOnlySpan{TPixel}, Span{Abgr32})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="Abgr32"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToAbgr32Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToAbgr32(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, Abgr32>(destination));
    }

    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="Bgr24"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Bgr24"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromBgr24(Configuration configuration, ReadOnlySpan<Bgr24> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref Bgr24 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromBgr24(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromBgr24(Configuration, ReadOnlySpan{Bgr24}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Bgr24"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromBgr24Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromBgr24(configuration, MemoryMarshal.Cast<byte, Bgr24>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="Bgr24"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="Bgr24"/> data.</param>
    public virtual void ToBgr24(Configuration configuration, ReadOnlySpan<TPixel> source, Span<Bgr24> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref Bgr24 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = Bgr24.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToBgr24(Configuration, ReadOnlySpan{TPixel}, Span{Bgr24})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="Bgr24"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToBgr24Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToBgr24(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, Bgr24>(destination));
    }

    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="Bgra32"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Bgra32"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromBgra32(Configuration configuration, ReadOnlySpan<Bgra32> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref Bgra32 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromBgra32(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromBgra32(Configuration, ReadOnlySpan{Bgra32}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Bgra32"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromBgra32Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromBgra32(configuration, MemoryMarshal.Cast<byte, Bgra32>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="Bgra32"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="Bgra32"/> data.</param>
    public virtual void ToBgra32(Configuration configuration, ReadOnlySpan<TPixel> source, Span<Bgra32> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref Bgra32 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = Bgra32.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToBgra32(Configuration, ReadOnlySpan{TPixel}, Span{Bgra32})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="Bgra32"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToBgra32Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToBgra32(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, Bgra32>(destination));
    }

    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="L8"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="L8"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromL8(Configuration configuration, ReadOnlySpan<L8> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref L8 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromL8(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromL8(Configuration, ReadOnlySpan{L8}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="L8"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromL8Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromL8(configuration, MemoryMarshal.Cast<byte, L8>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="L8"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="L8"/> data.</param>
    public virtual void ToL8(Configuration configuration, ReadOnlySpan<TPixel> source, Span<L8> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref L8 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = L8.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToL8(Configuration, ReadOnlySpan{TPixel}, Span{L8})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="L8"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToL8Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToL8(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, L8>(destination));
    }

    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="L16"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="L16"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromL16(Configuration configuration, ReadOnlySpan<L16> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref L16 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromL16(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromL16(Configuration, ReadOnlySpan{L16}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="L16"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromL16Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromL16(configuration, MemoryMarshal.Cast<byte, L16>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="L16"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="L16"/> data.</param>
    public virtual void ToL16(Configuration configuration, ReadOnlySpan<TPixel> source, Span<L16> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref L16 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = L16.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToL16(Configuration, ReadOnlySpan{TPixel}, Span{L16})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="L16"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToL16Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToL16(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, L16>(destination));
    }

    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="La16"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="La16"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromLa16(Configuration configuration, ReadOnlySpan<La16> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref La16 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromLa16(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromLa16(Configuration, ReadOnlySpan{La16}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="La16"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromLa16Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromLa16(configuration, MemoryMarshal.Cast<byte, La16>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="La16"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="La16"/> data.</param>
    public virtual void ToLa16(Configuration configuration, ReadOnlySpan<TPixel> source, Span<La16> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref La16 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = La16.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToLa16(Configuration, ReadOnlySpan{TPixel}, Span{La16})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="La16"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToLa16Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToLa16(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, La16>(destination));
    }

    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="La32"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="La32"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromLa32(Configuration configuration, ReadOnlySpan<La32> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref La32 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromLa32(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromLa32(Configuration, ReadOnlySpan{La32}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="La32"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromLa32Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromLa32(configuration, MemoryMarshal.Cast<byte, La32>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="La32"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="La32"/> data.</param>
    public virtual void ToLa32(Configuration configuration, ReadOnlySpan<TPixel> source, Span<La32> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref La32 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = La32.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToLa32(Configuration, ReadOnlySpan{TPixel}, Span{La32})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="La32"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToLa32Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToLa32(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, La32>(destination));
    }

    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="Rgb24"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgb24"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromRgb24(Configuration configuration, ReadOnlySpan<Rgb24> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref Rgb24 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromRgb24(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromRgb24(Configuration, ReadOnlySpan{Rgb24}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgb24"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromRgb24Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromRgb24(configuration, MemoryMarshal.Cast<byte, Rgb24>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="Rgb24"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="Rgb24"/> data.</param>
    public virtual void ToRgb24(Configuration configuration, ReadOnlySpan<TPixel> source, Span<Rgb24> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref Rgb24 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = Rgb24.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToRgb24(Configuration, ReadOnlySpan{TPixel}, Span{Rgb24})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="Rgb24"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToRgb24Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToRgb24(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, Rgb24>(destination));
    }

    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="Rgba32"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgba32"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromRgba32(Configuration configuration, ReadOnlySpan<Rgba32> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref Rgba32 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromRgba32(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromRgba32(Configuration, ReadOnlySpan{Rgba32}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgba32"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromRgba32Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromRgba32(configuration, MemoryMarshal.Cast<byte, Rgba32>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="Rgba32"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="Rgba32"/> data.</param>
    public virtual void ToRgba32(Configuration configuration, ReadOnlySpan<TPixel> source, Span<Rgba32> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref Rgba32 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = Rgba32.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToRgba32(Configuration, ReadOnlySpan{TPixel}, Span{Rgba32})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="Rgba32"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToRgba32Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToRgba32(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, Rgba32>(destination));
    }

    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="Rgb48"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgb48"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromRgb48(Configuration configuration, ReadOnlySpan<Rgb48> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref Rgb48 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromRgb48(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromRgb48(Configuration, ReadOnlySpan{Rgb48}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgb48"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromRgb48Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromRgb48(configuration, MemoryMarshal.Cast<byte, Rgb48>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="Rgb48"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="Rgb48"/> data.</param>
    public virtual void ToRgb48(Configuration configuration, ReadOnlySpan<TPixel> source, Span<Rgb48> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref Rgb48 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = Rgb48.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToRgb48(Configuration, ReadOnlySpan{TPixel}, Span{Rgb48})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="Rgb48"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToRgb48Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToRgb48(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, Rgb48>(destination));
    }

    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="Rgba64"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgba64"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromRgba64(Configuration configuration, ReadOnlySpan<Rgba64> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref Rgba64 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromRgba64(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromRgba64(Configuration, ReadOnlySpan{Rgba64}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgba64"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromRgba64Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromRgba64(configuration, MemoryMarshal.Cast<byte, Rgba64>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="Rgba64"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="Rgba64"/> data.</param>
    public virtual void ToRgba64(Configuration configuration, ReadOnlySpan<TPixel> source, Span<Rgba64> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref Rgba64 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = Rgba64.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToRgba64(Configuration, ReadOnlySpan{TPixel}, Span{Rgba64})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="Rgba64"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToRgba64Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToRgba64(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, Rgba64>(destination));
    }

    /// <summary>
    /// Converts all pixels in 'source` span of <see cref="Bgra5551"/> into a span of <typeparamref name="TPixel"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Bgra5551"/> data.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    public virtual void FromBgra5551(Configuration configuration, ReadOnlySpan<Bgra5551> source, Span<TPixel> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref Bgra5551 sourceBase = ref MemoryMarshal.GetReference(source);
        ref TPixel destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = TPixel.FromBgra5551(Unsafe.Add(ref sourceBase, i));
        }
    }

    /// <summary>
    /// A helper for <see cref="FromBgra5551(Configuration, ReadOnlySpan{Bgra5551}, Span{TPixel})"/> that expects a byte span.
    /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Bgra5551"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations.</param>
    /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination pixels.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void FromBgra5551Bytes(Configuration configuration, ReadOnlySpan<byte> sourceBytes, Span<TPixel> destination, int count)
    {
        this.FromBgra5551(configuration, MemoryMarshal.Cast<byte, Bgra5551>(sourceBytes).Slice(0, count), destination);
    }

    /// <summary>
    /// Converts all pixels of the 'source` span to a span of <see cref="Bgra5551"/>-s.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The span of source pixels</param>
    /// <param name="destination">The destination span of <see cref="Bgra5551"/> data.</param>
    public virtual void ToBgra5551(Configuration configuration, ReadOnlySpan<TPixel> source, Span<Bgra5551> destination)
    {
        Guard.DestinationShouldNotBeTooShort(source, destination, nameof(destination));

        ref TPixel sourceBase = ref MemoryMarshal.GetReference(source);
        ref Bgra5551 destinationBase = ref MemoryMarshal.GetReference(destination);

        for (nuint i = 0; i < (uint)source.Length; i++)
        {
            Unsafe.Add(ref destinationBase, i) = Bgra5551.FromScaledVector4(Unsafe.Add(ref sourceBase, i).ToScaledVector4());
        }
    }

    /// <summary>
    /// A helper for <see cref="ToBgra5551(Configuration, ReadOnlySpan{TPixel}, Span{Bgra5551})"/> that expects a byte span as destination.
    /// The layout of the data in 'destination' must be compatible with <see cref="Bgra5551"/> layout.
    /// </summary>
    /// <param name="configuration">A <see cref="Configuration"/> to configure internal operations</param>
    /// <param name="source">The <see cref="Span{T}"/> to the source pixels.</param>
    /// <param name="destination">The <see cref="Span{T}"/> to the destination bytes.</param>
    /// <param name="count">The number of pixels to convert.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ToBgra5551Bytes(Configuration configuration, ReadOnlySpan<TPixel> source, Span<byte> destination, int count)
    {
        this.ToBgra5551(configuration, source.Slice(0, count), MemoryMarshal.Cast<byte, Bgra5551>(destination));
    }
}
