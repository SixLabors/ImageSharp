// This file isn't generated, but this comment is necessary to exclude it from StyleCop analysis.
// <auto-generated/>
//Apache2, 2014-2016, Samuel Carlsson, WinterDev


using System.Collections.Generic;
using System.IO;
namespace NOpenType.Tables
{
    class Kern : TableEntry
    {
        //https://www.microsoft.com/typography/otspec/kern.htm

        List<KerningSubTable> kernSubTables = new List<KerningSubTable>();

        public override string Name
        {
            get { return "kern"; }
        }
        public short GetKerningDistance(ushort left, ushort right)
        {
            //use kern sub table 0
            //TODO: review if have more than 1 table
            return kernSubTables[0].GetKernDistance(left, right);
        }
        protected override void ReadContentFrom(BinaryReader reader)
        {
            ushort verion = reader.ReadUInt16();
            ushort nTables = reader.ReadUInt16();//subtable count
            //TODO: review here
            if (nTables > 1)
            {
                throw new System.NotSupportedException();
            }

            for (int i = 0; i < nTables; ++i)
            {
                ushort subTableVersion = reader.ReadUInt16();
                ushort len = reader.ReadUInt16(); //Length of the subtable, in bytes (including this header).
                KernCoverage kerCoverage = new KernCoverage(reader.ReadUInt16());//What type of information is contained in this table.
                //The coverage field is divided into the following sub-fields, with sizes given in bits:
                //----------------------------------------------
                switch (kerCoverage.format)
                {
                    case 0:
                        ReadSubTableFormat0(reader, len - (7 * 2));//7 fields * 2 byte each
                        break;
                    case 2:
                        //TODO: implement
                        throw new System.NotImplementedException();
                    default:
                        throw new System.NotSupportedException();
                }

            }
        }

        void ReadSubTableFormat0(BinaryReader reader, int remainingBytes)
        {
            ushort npairs = reader.ReadUInt16();
            ushort searchRange = reader.ReadUInt16();
            ushort entrySelector = reader.ReadUInt16();
            ushort rangeShift = reader.ReadUInt16();
            //----------------------------------------------

            //check 
//#if DEBUG
//            if ((remainingBytes % 6) != 0)
//            {
//                throw new System.Exception();
//            }
//            int calNpairs = remainingBytes / 6;
//#endif
            var ksubTable = new KerningSubTable(npairs);
            this.kernSubTables.Add(ksubTable);

            while (remainingBytes > 0)
            {
                ushort left = reader.ReadUInt16();
                ushort right = reader.ReadUInt16();
                short value = reader.ReadInt16();
                ksubTable.AddKernPair(
                    reader.ReadUInt16(), //left
                    reader.ReadUInt16(),//right
                    reader.ReadInt16());//value

                remainingBytes -= 6;
            }
        }
        struct KerningPair
        {
            /// <summary>
            /// left glyph index
            /// </summary>
            public readonly ushort left;
            /// <summary>
            /// right glyph index
            /// </summary>
            public readonly ushort right;
            /// <summary>
            /// n FUnits. If this value is greater than zero, the characters will be moved apart. If this value is less than zero, the character will be moved closer together.
            /// </summary>
            public readonly short value;
            public KerningPair(ushort left, ushort right, short value)
            {
                this.left = left;
                this.right = right;
                this.value = value;
            }
#if DEBUG
            public override string ToString()
            {
                return left + " " + right;
            }
#endif
        }
        struct KernCoverage
        {
            //horizontal 	0 	1 	1 if table has horizontal data, 0 if vertical.
            //minimum 	1 	1 	If this bit is set to 1, the table has minimum values. If set to 0, the table has kerning values.
            //cross-stream 	2 	1 	If set to 1, kerning is perpendicular to the flow of the text.

            //If the text is normally written horizontally, kerning will be done in the up and down directions. If kerning values are positive, the text will be kerned upwards; if they are negative, the text will be kerned downwards.

            //If the text is normally written vertically, kerning will be done in the left and right directions. If kerning values are positive, the text will be kerned to the right; if they are negative, the text will be kerned to the left.

            //The value 0x8000 in the kerning data resets the cross-stream kerning back to 0.
            //override 	3 	1 	If this bit is set to 1 the value in this table should replace the value currently being accumulated.
            //reserved1 	4-7 	4 	Reserved. This should be set to zero.
            //format 	8-15 	8 	Format of the subtable. Only formats 0 and 2 have been defined. Formats 1 and 3 through 255 are reserved for future use.
            //
            public readonly ushort coverage;
            public readonly bool horizontal;
            public readonly bool hasMinimum;
            public readonly bool crossStream;
            public readonly bool _override;
            public readonly byte format;
            public KernCoverage(ushort coverage)
            {
                this.coverage = coverage;
                //bit 0,len 1, 1 if table has horizontal data, 0 if vertical.
                horizontal = (coverage & 0x1) == 1;
                //bit 1,len 1, If this bit is set to 1, the table has minimum values. If set to 0, the table has kerning values.
                hasMinimum = ((coverage >> 1) & 0x1) == 1;
                //bit 2,len 1, If set to 1, kerning is perpendicular to the flow of the text.
                crossStream = ((coverage >> 2) & 0x1) == 1;
                //bit 3,len 1, If this bit is set to 1 the value in this table should replace the value currently being accumulated.
                _override = ((coverage >> 3) & 0x1) == 1;
                //bit 4-7 => 	Reserved. This should be set to zero.
                format = (byte)((coverage >> 7) & 0xff);
            }
        }

        class KerningSubTable
        {
            List<KerningPair> kernPairs;
            Dictionary<uint, short> kernDic;
            public KerningSubTable(int capcity)
            {
                kernPairs = new List<KerningPair>(capcity);
                kernDic = new Dictionary<uint, short>(capcity);
            }
            public void AddKernPair(ushort left, ushort right, short value)
            {
                kernPairs.Add(new KerningPair(left, right, value));
                //may has duplicate key ?
                //TODO: review here
                uint key = (uint)((left << 16) | right);
                kernDic[key] = value; //just replace?                 
            }
            public short GetKernDistance(ushort left, ushort right)
            {
                //find if we have this left & right ?
                uint key = (uint)((left << 16) | right);
                short found;
                kernDic.TryGetValue(key, out found);
                return found;
            }
        }

    }
}