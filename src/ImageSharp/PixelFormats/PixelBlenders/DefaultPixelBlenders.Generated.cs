// Copyright (c) Six Labors.
// Licensed under the Six Labors Split License.

// <auto-generated />
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;

namespace SixLabors.ImageSharp.PixelFormats.PixelBlenders;

/// <summary>
/// Collection of Porter Duff alpha blending functions applying different composition models.
/// </summary>
/// <remarks>
/// These functions are designed to be a general solution for all color cases,
/// that is, they take in account the alpha value of both the backdrop
/// and source, and there's no need to alpha-premultiply neither the backdrop
/// nor the source.
/// Note there are faster functions for when the backdrop color is known
/// to be opaque
/// </remarks>
internal static class DefaultPixelBlenders<TPixel>
    where TPixel : unmanaged, IPixel<TPixel>
{

    /// <summary>
    /// A pixel blender that implements the "NormalSrc" composition equation.
    /// </summary>
    public class NormalSrc : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static NormalSrc Instance { get; } = new NormalSrc();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.NormalSrc(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.NormalSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalSrc(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalSrc(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.NormalSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "MultiplySrc" composition equation.
    /// </summary>
    public class MultiplySrc : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static MultiplySrc Instance { get; } = new MultiplySrc();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.MultiplySrc(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.MultiplySrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplySrc(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplySrc(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.MultiplySrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplySrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplySrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "AddSrc" composition equation.
    /// </summary>
    public class AddSrc : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static AddSrc Instance { get; } = new AddSrc();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.AddSrc(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.AddSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddSrc(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddSrc(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.AddSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "SubtractSrc" composition equation.
    /// </summary>
    public class SubtractSrc : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static SubtractSrc Instance { get; } = new SubtractSrc();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.SubtractSrc(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.SubtractSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractSrc(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractSrc(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.SubtractSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "ScreenSrc" composition equation.
    /// </summary>
    public class ScreenSrc : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static ScreenSrc Instance { get; } = new ScreenSrc();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.ScreenSrc(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.ScreenSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenSrc(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenSrc(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.ScreenSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "DarkenSrc" composition equation.
    /// </summary>
    public class DarkenSrc : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static DarkenSrc Instance { get; } = new DarkenSrc();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.DarkenSrc(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.DarkenSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenSrc(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenSrc(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.DarkenSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "LightenSrc" composition equation.
    /// </summary>
    public class LightenSrc : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static LightenSrc Instance { get; } = new LightenSrc();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.LightenSrc(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.LightenSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenSrc(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenSrc(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.LightenSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "OverlaySrc" composition equation.
    /// </summary>
    public class OverlaySrc : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static OverlaySrc Instance { get; } = new OverlaySrc();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.OverlaySrc(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.OverlaySrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlaySrc(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlaySrc(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.OverlaySrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlaySrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlaySrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "HardLightSrc" composition equation.
    /// </summary>
    public class HardLightSrc : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static HardLightSrc Instance { get; } = new HardLightSrc();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.HardLightSrc(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.HardLightSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightSrc(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightSrc(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.HardLightSrc(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightSrc(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "NormalSrcAtop" composition equation.
    /// </summary>
    public class NormalSrcAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static NormalSrcAtop Instance { get; } = new NormalSrcAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.NormalSrcAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.NormalSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalSrcAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalSrcAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.NormalSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "MultiplySrcAtop" composition equation.
    /// </summary>
    public class MultiplySrcAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static MultiplySrcAtop Instance { get; } = new MultiplySrcAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.MultiplySrcAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.MultiplySrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplySrcAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplySrcAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.MultiplySrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplySrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplySrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "AddSrcAtop" composition equation.
    /// </summary>
    public class AddSrcAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static AddSrcAtop Instance { get; } = new AddSrcAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.AddSrcAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.AddSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddSrcAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddSrcAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.AddSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "SubtractSrcAtop" composition equation.
    /// </summary>
    public class SubtractSrcAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static SubtractSrcAtop Instance { get; } = new SubtractSrcAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.SubtractSrcAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.SubtractSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractSrcAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractSrcAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.SubtractSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "ScreenSrcAtop" composition equation.
    /// </summary>
    public class ScreenSrcAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static ScreenSrcAtop Instance { get; } = new ScreenSrcAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.ScreenSrcAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.ScreenSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenSrcAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenSrcAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.ScreenSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "DarkenSrcAtop" composition equation.
    /// </summary>
    public class DarkenSrcAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static DarkenSrcAtop Instance { get; } = new DarkenSrcAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.DarkenSrcAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.DarkenSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenSrcAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenSrcAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.DarkenSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "LightenSrcAtop" composition equation.
    /// </summary>
    public class LightenSrcAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static LightenSrcAtop Instance { get; } = new LightenSrcAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.LightenSrcAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.LightenSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenSrcAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenSrcAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.LightenSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "OverlaySrcAtop" composition equation.
    /// </summary>
    public class OverlaySrcAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static OverlaySrcAtop Instance { get; } = new OverlaySrcAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.OverlaySrcAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.OverlaySrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlaySrcAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlaySrcAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.OverlaySrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlaySrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlaySrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "HardLightSrcAtop" composition equation.
    /// </summary>
    public class HardLightSrcAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static HardLightSrcAtop Instance { get; } = new HardLightSrcAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.HardLightSrcAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.HardLightSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightSrcAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightSrcAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.HardLightSrcAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightSrcAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "NormalSrcOver" composition equation.
    /// </summary>
    public class NormalSrcOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static NormalSrcOver Instance { get; } = new NormalSrcOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.NormalSrcOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.NormalSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalSrcOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalSrcOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.NormalSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "MultiplySrcOver" composition equation.
    /// </summary>
    public class MultiplySrcOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static MultiplySrcOver Instance { get; } = new MultiplySrcOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.MultiplySrcOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.MultiplySrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplySrcOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplySrcOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.MultiplySrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplySrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplySrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "AddSrcOver" composition equation.
    /// </summary>
    public class AddSrcOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static AddSrcOver Instance { get; } = new AddSrcOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.AddSrcOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.AddSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddSrcOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddSrcOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.AddSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "SubtractSrcOver" composition equation.
    /// </summary>
    public class SubtractSrcOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static SubtractSrcOver Instance { get; } = new SubtractSrcOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.SubtractSrcOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.SubtractSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractSrcOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractSrcOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.SubtractSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "ScreenSrcOver" composition equation.
    /// </summary>
    public class ScreenSrcOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static ScreenSrcOver Instance { get; } = new ScreenSrcOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.ScreenSrcOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.ScreenSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenSrcOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenSrcOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.ScreenSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "DarkenSrcOver" composition equation.
    /// </summary>
    public class DarkenSrcOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static DarkenSrcOver Instance { get; } = new DarkenSrcOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.DarkenSrcOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.DarkenSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenSrcOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenSrcOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.DarkenSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "LightenSrcOver" composition equation.
    /// </summary>
    public class LightenSrcOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static LightenSrcOver Instance { get; } = new LightenSrcOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.LightenSrcOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.LightenSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenSrcOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenSrcOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.LightenSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "OverlaySrcOver" composition equation.
    /// </summary>
    public class OverlaySrcOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static OverlaySrcOver Instance { get; } = new OverlaySrcOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.OverlaySrcOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.OverlaySrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlaySrcOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlaySrcOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.OverlaySrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlaySrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlaySrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "HardLightSrcOver" composition equation.
    /// </summary>
    public class HardLightSrcOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static HardLightSrcOver Instance { get; } = new HardLightSrcOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.HardLightSrcOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.HardLightSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightSrcOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightSrcOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.HardLightSrcOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightSrcOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "NormalSrcIn" composition equation.
    /// </summary>
    public class NormalSrcIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static NormalSrcIn Instance { get; } = new NormalSrcIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.NormalSrcIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.NormalSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalSrcIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalSrcIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.NormalSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "MultiplySrcIn" composition equation.
    /// </summary>
    public class MultiplySrcIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static MultiplySrcIn Instance { get; } = new MultiplySrcIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.MultiplySrcIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.MultiplySrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplySrcIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplySrcIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.MultiplySrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplySrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplySrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "AddSrcIn" composition equation.
    /// </summary>
    public class AddSrcIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static AddSrcIn Instance { get; } = new AddSrcIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.AddSrcIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.AddSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddSrcIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddSrcIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.AddSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "SubtractSrcIn" composition equation.
    /// </summary>
    public class SubtractSrcIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static SubtractSrcIn Instance { get; } = new SubtractSrcIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.SubtractSrcIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.SubtractSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractSrcIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractSrcIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.SubtractSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "ScreenSrcIn" composition equation.
    /// </summary>
    public class ScreenSrcIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static ScreenSrcIn Instance { get; } = new ScreenSrcIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.ScreenSrcIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.ScreenSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenSrcIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenSrcIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.ScreenSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "DarkenSrcIn" composition equation.
    /// </summary>
    public class DarkenSrcIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static DarkenSrcIn Instance { get; } = new DarkenSrcIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.DarkenSrcIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.DarkenSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenSrcIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenSrcIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.DarkenSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "LightenSrcIn" composition equation.
    /// </summary>
    public class LightenSrcIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static LightenSrcIn Instance { get; } = new LightenSrcIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.LightenSrcIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.LightenSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenSrcIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenSrcIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.LightenSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "OverlaySrcIn" composition equation.
    /// </summary>
    public class OverlaySrcIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static OverlaySrcIn Instance { get; } = new OverlaySrcIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.OverlaySrcIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.OverlaySrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlaySrcIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlaySrcIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.OverlaySrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlaySrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlaySrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "HardLightSrcIn" composition equation.
    /// </summary>
    public class HardLightSrcIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static HardLightSrcIn Instance { get; } = new HardLightSrcIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.HardLightSrcIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.HardLightSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightSrcIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightSrcIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.HardLightSrcIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightSrcIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "NormalSrcOut" composition equation.
    /// </summary>
    public class NormalSrcOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static NormalSrcOut Instance { get; } = new NormalSrcOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.NormalSrcOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.NormalSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalSrcOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalSrcOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.NormalSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "MultiplySrcOut" composition equation.
    /// </summary>
    public class MultiplySrcOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static MultiplySrcOut Instance { get; } = new MultiplySrcOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.MultiplySrcOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.MultiplySrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplySrcOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplySrcOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.MultiplySrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplySrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplySrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "AddSrcOut" composition equation.
    /// </summary>
    public class AddSrcOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static AddSrcOut Instance { get; } = new AddSrcOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.AddSrcOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.AddSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddSrcOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddSrcOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.AddSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "SubtractSrcOut" composition equation.
    /// </summary>
    public class SubtractSrcOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static SubtractSrcOut Instance { get; } = new SubtractSrcOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.SubtractSrcOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.SubtractSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractSrcOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractSrcOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.SubtractSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "ScreenSrcOut" composition equation.
    /// </summary>
    public class ScreenSrcOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static ScreenSrcOut Instance { get; } = new ScreenSrcOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.ScreenSrcOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.ScreenSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenSrcOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenSrcOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.ScreenSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "DarkenSrcOut" composition equation.
    /// </summary>
    public class DarkenSrcOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static DarkenSrcOut Instance { get; } = new DarkenSrcOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.DarkenSrcOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.DarkenSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenSrcOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenSrcOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.DarkenSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "LightenSrcOut" composition equation.
    /// </summary>
    public class LightenSrcOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static LightenSrcOut Instance { get; } = new LightenSrcOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.LightenSrcOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.LightenSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenSrcOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenSrcOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.LightenSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "OverlaySrcOut" composition equation.
    /// </summary>
    public class OverlaySrcOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static OverlaySrcOut Instance { get; } = new OverlaySrcOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.OverlaySrcOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.OverlaySrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlaySrcOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlaySrcOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.OverlaySrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlaySrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlaySrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "HardLightSrcOut" composition equation.
    /// </summary>
    public class HardLightSrcOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static HardLightSrcOut Instance { get; } = new HardLightSrcOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.HardLightSrcOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.HardLightSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightSrcOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightSrcOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.HardLightSrcOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightSrcOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "NormalDest" composition equation.
    /// </summary>
    public class NormalDest : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static NormalDest Instance { get; } = new NormalDest();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.NormalDest(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.NormalDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalDest(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalDest(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.NormalDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "MultiplyDest" composition equation.
    /// </summary>
    public class MultiplyDest : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static MultiplyDest Instance { get; } = new MultiplyDest();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.MultiplyDest(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.MultiplyDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyDest(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyDest(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.MultiplyDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "AddDest" composition equation.
    /// </summary>
    public class AddDest : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static AddDest Instance { get; } = new AddDest();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.AddDest(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.AddDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddDest(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddDest(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.AddDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "SubtractDest" composition equation.
    /// </summary>
    public class SubtractDest : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static SubtractDest Instance { get; } = new SubtractDest();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.SubtractDest(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.SubtractDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractDest(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractDest(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.SubtractDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "ScreenDest" composition equation.
    /// </summary>
    public class ScreenDest : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static ScreenDest Instance { get; } = new ScreenDest();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.ScreenDest(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.ScreenDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenDest(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenDest(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.ScreenDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "DarkenDest" composition equation.
    /// </summary>
    public class DarkenDest : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static DarkenDest Instance { get; } = new DarkenDest();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.DarkenDest(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.DarkenDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenDest(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenDest(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.DarkenDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "LightenDest" composition equation.
    /// </summary>
    public class LightenDest : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static LightenDest Instance { get; } = new LightenDest();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.LightenDest(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.LightenDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenDest(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenDest(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.LightenDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "OverlayDest" composition equation.
    /// </summary>
    public class OverlayDest : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static OverlayDest Instance { get; } = new OverlayDest();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.OverlayDest(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.OverlayDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayDest(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayDest(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.OverlayDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "HardLightDest" composition equation.
    /// </summary>
    public class HardLightDest : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static HardLightDest Instance { get; } = new HardLightDest();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.HardLightDest(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.HardLightDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightDest(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightDest(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.HardLightDest(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightDest(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "NormalDestAtop" composition equation.
    /// </summary>
    public class NormalDestAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static NormalDestAtop Instance { get; } = new NormalDestAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.NormalDestAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.NormalDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalDestAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalDestAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.NormalDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "MultiplyDestAtop" composition equation.
    /// </summary>
    public class MultiplyDestAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static MultiplyDestAtop Instance { get; } = new MultiplyDestAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.MultiplyDestAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.MultiplyDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyDestAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyDestAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.MultiplyDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "AddDestAtop" composition equation.
    /// </summary>
    public class AddDestAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static AddDestAtop Instance { get; } = new AddDestAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.AddDestAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.AddDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddDestAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddDestAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.AddDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "SubtractDestAtop" composition equation.
    /// </summary>
    public class SubtractDestAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static SubtractDestAtop Instance { get; } = new SubtractDestAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.SubtractDestAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.SubtractDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractDestAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractDestAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.SubtractDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "ScreenDestAtop" composition equation.
    /// </summary>
    public class ScreenDestAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static ScreenDestAtop Instance { get; } = new ScreenDestAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.ScreenDestAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.ScreenDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenDestAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenDestAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.ScreenDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "DarkenDestAtop" composition equation.
    /// </summary>
    public class DarkenDestAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static DarkenDestAtop Instance { get; } = new DarkenDestAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.DarkenDestAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.DarkenDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenDestAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenDestAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.DarkenDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "LightenDestAtop" composition equation.
    /// </summary>
    public class LightenDestAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static LightenDestAtop Instance { get; } = new LightenDestAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.LightenDestAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.LightenDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenDestAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenDestAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.LightenDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "OverlayDestAtop" composition equation.
    /// </summary>
    public class OverlayDestAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static OverlayDestAtop Instance { get; } = new OverlayDestAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.OverlayDestAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.OverlayDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayDestAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayDestAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.OverlayDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "HardLightDestAtop" composition equation.
    /// </summary>
    public class HardLightDestAtop : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static HardLightDestAtop Instance { get; } = new HardLightDestAtop();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.HardLightDestAtop(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.HardLightDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightDestAtop(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightDestAtop(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.HardLightDestAtop(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightDestAtop(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "NormalDestOver" composition equation.
    /// </summary>
    public class NormalDestOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static NormalDestOver Instance { get; } = new NormalDestOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.NormalDestOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.NormalDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalDestOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalDestOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.NormalDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "MultiplyDestOver" composition equation.
    /// </summary>
    public class MultiplyDestOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static MultiplyDestOver Instance { get; } = new MultiplyDestOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.MultiplyDestOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.MultiplyDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyDestOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyDestOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.MultiplyDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "AddDestOver" composition equation.
    /// </summary>
    public class AddDestOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static AddDestOver Instance { get; } = new AddDestOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.AddDestOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.AddDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddDestOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddDestOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.AddDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "SubtractDestOver" composition equation.
    /// </summary>
    public class SubtractDestOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static SubtractDestOver Instance { get; } = new SubtractDestOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.SubtractDestOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.SubtractDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractDestOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractDestOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.SubtractDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "ScreenDestOver" composition equation.
    /// </summary>
    public class ScreenDestOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static ScreenDestOver Instance { get; } = new ScreenDestOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.ScreenDestOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.ScreenDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenDestOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenDestOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.ScreenDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "DarkenDestOver" composition equation.
    /// </summary>
    public class DarkenDestOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static DarkenDestOver Instance { get; } = new DarkenDestOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.DarkenDestOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.DarkenDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenDestOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenDestOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.DarkenDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "LightenDestOver" composition equation.
    /// </summary>
    public class LightenDestOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static LightenDestOver Instance { get; } = new LightenDestOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.LightenDestOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.LightenDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenDestOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenDestOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.LightenDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "OverlayDestOver" composition equation.
    /// </summary>
    public class OverlayDestOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static OverlayDestOver Instance { get; } = new OverlayDestOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.OverlayDestOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.OverlayDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayDestOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayDestOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.OverlayDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "HardLightDestOver" composition equation.
    /// </summary>
    public class HardLightDestOver : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static HardLightDestOver Instance { get; } = new HardLightDestOver();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.HardLightDestOver(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.HardLightDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightDestOver(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightDestOver(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.HardLightDestOver(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightDestOver(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "NormalDestIn" composition equation.
    /// </summary>
    public class NormalDestIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static NormalDestIn Instance { get; } = new NormalDestIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.NormalDestIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.NormalDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalDestIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalDestIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.NormalDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "MultiplyDestIn" composition equation.
    /// </summary>
    public class MultiplyDestIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static MultiplyDestIn Instance { get; } = new MultiplyDestIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.MultiplyDestIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.MultiplyDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyDestIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyDestIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.MultiplyDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "AddDestIn" composition equation.
    /// </summary>
    public class AddDestIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static AddDestIn Instance { get; } = new AddDestIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.AddDestIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.AddDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddDestIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddDestIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.AddDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "SubtractDestIn" composition equation.
    /// </summary>
    public class SubtractDestIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static SubtractDestIn Instance { get; } = new SubtractDestIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.SubtractDestIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.SubtractDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractDestIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractDestIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.SubtractDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "ScreenDestIn" composition equation.
    /// </summary>
    public class ScreenDestIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static ScreenDestIn Instance { get; } = new ScreenDestIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.ScreenDestIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.ScreenDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenDestIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenDestIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.ScreenDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "DarkenDestIn" composition equation.
    /// </summary>
    public class DarkenDestIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static DarkenDestIn Instance { get; } = new DarkenDestIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.DarkenDestIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.DarkenDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenDestIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenDestIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.DarkenDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "LightenDestIn" composition equation.
    /// </summary>
    public class LightenDestIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static LightenDestIn Instance { get; } = new LightenDestIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.LightenDestIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.LightenDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenDestIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenDestIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.LightenDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "OverlayDestIn" composition equation.
    /// </summary>
    public class OverlayDestIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static OverlayDestIn Instance { get; } = new OverlayDestIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.OverlayDestIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.OverlayDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayDestIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayDestIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.OverlayDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "HardLightDestIn" composition equation.
    /// </summary>
    public class HardLightDestIn : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static HardLightDestIn Instance { get; } = new HardLightDestIn();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.HardLightDestIn(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.HardLightDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightDestIn(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightDestIn(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.HardLightDestIn(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightDestIn(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "NormalDestOut" composition equation.
    /// </summary>
    public class NormalDestOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static NormalDestOut Instance { get; } = new NormalDestOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.NormalDestOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.NormalDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalDestOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalDestOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.NormalDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "MultiplyDestOut" composition equation.
    /// </summary>
    public class MultiplyDestOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static MultiplyDestOut Instance { get; } = new MultiplyDestOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.MultiplyDestOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.MultiplyDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyDestOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyDestOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.MultiplyDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "AddDestOut" composition equation.
    /// </summary>
    public class AddDestOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static AddDestOut Instance { get; } = new AddDestOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.AddDestOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.AddDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddDestOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddDestOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.AddDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "SubtractDestOut" composition equation.
    /// </summary>
    public class SubtractDestOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static SubtractDestOut Instance { get; } = new SubtractDestOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.SubtractDestOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.SubtractDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractDestOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractDestOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.SubtractDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "ScreenDestOut" composition equation.
    /// </summary>
    public class ScreenDestOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static ScreenDestOut Instance { get; } = new ScreenDestOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.ScreenDestOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.ScreenDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenDestOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenDestOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.ScreenDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "DarkenDestOut" composition equation.
    /// </summary>
    public class DarkenDestOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static DarkenDestOut Instance { get; } = new DarkenDestOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.DarkenDestOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.DarkenDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenDestOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenDestOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.DarkenDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "LightenDestOut" composition equation.
    /// </summary>
    public class LightenDestOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static LightenDestOut Instance { get; } = new LightenDestOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.LightenDestOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.LightenDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenDestOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenDestOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.LightenDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "OverlayDestOut" composition equation.
    /// </summary>
    public class OverlayDestOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static OverlayDestOut Instance { get; } = new OverlayDestOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.OverlayDestOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.OverlayDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayDestOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayDestOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.OverlayDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "HardLightDestOut" composition equation.
    /// </summary>
    public class HardLightDestOut : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static HardLightDestOut Instance { get; } = new HardLightDestOut();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.HardLightDestOut(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.HardLightDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightDestOut(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightDestOut(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.HardLightDestOut(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightDestOut(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "NormalClear" composition equation.
    /// </summary>
    public class NormalClear : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static NormalClear Instance { get; } = new NormalClear();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.NormalClear(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.NormalClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalClear(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalClear(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.NormalClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "MultiplyClear" composition equation.
    /// </summary>
    public class MultiplyClear : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static MultiplyClear Instance { get; } = new MultiplyClear();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.MultiplyClear(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.MultiplyClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyClear(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyClear(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.MultiplyClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "AddClear" composition equation.
    /// </summary>
    public class AddClear : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static AddClear Instance { get; } = new AddClear();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.AddClear(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.AddClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddClear(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddClear(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.AddClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "SubtractClear" composition equation.
    /// </summary>
    public class SubtractClear : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static SubtractClear Instance { get; } = new SubtractClear();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.SubtractClear(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.SubtractClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractClear(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractClear(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.SubtractClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "ScreenClear" composition equation.
    /// </summary>
    public class ScreenClear : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static ScreenClear Instance { get; } = new ScreenClear();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.ScreenClear(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.ScreenClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenClear(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenClear(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.ScreenClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "DarkenClear" composition equation.
    /// </summary>
    public class DarkenClear : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static DarkenClear Instance { get; } = new DarkenClear();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.DarkenClear(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.DarkenClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenClear(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenClear(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.DarkenClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "LightenClear" composition equation.
    /// </summary>
    public class LightenClear : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static LightenClear Instance { get; } = new LightenClear();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.LightenClear(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.LightenClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenClear(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenClear(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.LightenClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "OverlayClear" composition equation.
    /// </summary>
    public class OverlayClear : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static OverlayClear Instance { get; } = new OverlayClear();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.OverlayClear(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.OverlayClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayClear(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayClear(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.OverlayClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "HardLightClear" composition equation.
    /// </summary>
    public class HardLightClear : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static HardLightClear Instance { get; } = new HardLightClear();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.HardLightClear(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.HardLightClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightClear(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightClear(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.HardLightClear(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightClear(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "NormalXor" composition equation.
    /// </summary>
    public class NormalXor : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static NormalXor Instance { get; } = new NormalXor();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.NormalXor(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.NormalXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalXor(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalXor(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.NormalXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.NormalXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.NormalXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "MultiplyXor" composition equation.
    /// </summary>
    public class MultiplyXor : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static MultiplyXor Instance { get; } = new MultiplyXor();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.MultiplyXor(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.MultiplyXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyXor(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyXor(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.MultiplyXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.MultiplyXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.MultiplyXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "AddXor" composition equation.
    /// </summary>
    public class AddXor : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static AddXor Instance { get; } = new AddXor();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.AddXor(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.AddXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddXor(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddXor(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.AddXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.AddXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.AddXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "SubtractXor" composition equation.
    /// </summary>
    public class SubtractXor : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static SubtractXor Instance { get; } = new SubtractXor();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.SubtractXor(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.SubtractXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractXor(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractXor(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.SubtractXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.SubtractXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.SubtractXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "ScreenXor" composition equation.
    /// </summary>
    public class ScreenXor : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static ScreenXor Instance { get; } = new ScreenXor();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.ScreenXor(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.ScreenXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenXor(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenXor(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.ScreenXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.ScreenXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.ScreenXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "DarkenXor" composition equation.
    /// </summary>
    public class DarkenXor : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static DarkenXor Instance { get; } = new DarkenXor();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.DarkenXor(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.DarkenXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenXor(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenXor(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.DarkenXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.DarkenXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.DarkenXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "LightenXor" composition equation.
    /// </summary>
    public class LightenXor : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static LightenXor Instance { get; } = new LightenXor();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.LightenXor(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.LightenXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenXor(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenXor(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.LightenXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.LightenXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.LightenXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "OverlayXor" composition equation.
    /// </summary>
    public class OverlayXor : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static OverlayXor Instance { get; } = new OverlayXor();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.OverlayXor(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.OverlayXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayXor(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayXor(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.OverlayXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.OverlayXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.OverlayXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

    /// <summary>
    /// A pixel blender that implements the "HardLightXor" composition equation.
    /// </summary>
    public class HardLightXor : PixelBlender<TPixel>
    {
        /// <summary>
        /// Gets the static instance of this blender.
        /// </summary>
        public static HardLightXor Instance { get; } = new HardLightXor();

        /// <inheritdoc />
        public override TPixel Blend(TPixel background, TPixel source, float amount)
        {
            return TPixel.FromScaledVector4(PorterDuffFunctions.HardLightXor(background.ToScaledVector4(), source.ToScaledVector4(), Numerics.Clamp(amount, 0, 1)));
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, float amount)
        {
            amount = Numerics.Clamp(amount, 0, 1);

            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                Vector256<float> opacity = Vector256.Create(amount);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    destinationBase = PorterDuffFunctions.HardLightXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightXor(background[i], source[i], amount);
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightXor(background[i], source[i], amount);
                }
            }
        }

        /// <inheritdoc />
        protected override void BlendFunction(Span<Vector4> destination, ReadOnlySpan<Vector4> background, ReadOnlySpan<Vector4> source, ReadOnlySpan<float> amount)
        {
            if (Avx2.IsSupported && destination.Length >= 2)
            {
                // Divide by 2 as 4 elements per Vector4 and 8 per Vector256<float>
                ref Vector256<float> destinationBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(destination));
                ref Vector256<float> destinationLast = ref Unsafe.Add(ref destinationBase, (uint)destination.Length / 2u);

                ref Vector256<float> backgroundBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(background));
                ref Vector256<float> sourceBase = ref Unsafe.As<Vector4, Vector256<float>>(ref MemoryMarshal.GetReference(source));
                ref float amountBase = ref MemoryMarshal.GetReference(amount);

                Vector256<float> vOne = Vector256.Create(1F);

                while (Unsafe.IsAddressLessThan(ref destinationBase, ref destinationLast))
                {
                    // We need to create a Vector256<float> containing the current and next amount values
                    // taking up each half of the Vector256<float> and then clamp them.
                    Vector256<float> opacity = Vector256.Create(
                        Vector128.Create(amountBase),
                        Vector128.Create(Unsafe.Add(ref amountBase, 1)));
                    opacity = Avx.Min(Avx.Max(Vector256<float>.Zero, opacity), vOne);

                    destinationBase = PorterDuffFunctions.HardLightXor(backgroundBase, sourceBase, opacity);
                    destinationBase = ref Unsafe.Add(ref destinationBase, 1);
                    backgroundBase = ref Unsafe.Add(ref backgroundBase, 1);
                    sourceBase = ref Unsafe.Add(ref sourceBase, 1);
                    amountBase = ref Unsafe.Add(ref amountBase, 2);
                }

                if (Numerics.Modulo2(destination.Length) != 0)
                {
                    // Vector4 fits neatly in pairs. Any overlap has to be equal to 1.
                    int i = destination.Length - 1;
                    destination[i] = PorterDuffFunctions.HardLightXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
            else
            {
                for (int i = 0; i < destination.Length; i++)
                {
                    destination[i] = PorterDuffFunctions.HardLightXor(background[i], source[i], Numerics.Clamp(amount[i], 0, 1F));
                }
            }
        }
    }

}
